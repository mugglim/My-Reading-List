# CHAPTER 9 - 계층형 설계 II

### 계층형 설계 패턴

**추상화 벽 패턴**

- 추상화 벽 패턴은 특정 계층에서만 세부적인 사항을 다루는 방법이다.
- 추상화 벽의 상위 계층은 하위 계층과 의존성이 없다. 추상화 벽 계층의 코드가 변경되어도 상위 계층의 코드의 실행에는 아무 문제가 없다.

```js
/**
 * 장바구니의 금액 합계가 20이 넘는지 확인
 * - getFreeShipping은 cart가 배열에서 객체로 바뀌어도 문제가
 * */

const getFreeShipping = cart => calcTotal(cart) >= 20;

/**
 * 장바구니의 금액의 합계를 구하는 함수
 */
const calcTotal = cart => cart.reduce((acc, item) => acc + item.price, 0);
```

**작은 인터페이스(Minimal interface) 패턴**

- 작은 인터페이스 패턴은 비즈니스를 대표하는 개념을 인터페이스화 하는 방법이다.
  - 특히 추상화 벽에 있는 인터페이스는 어떤 공통된 값을 접근하거나 조작할 수 있음. (read and write)
- 인터페이스의 개수가 작아지면 하위 계층에 불필요한 기능이 커지는 것을 막을 수 있다.
- 새로운 인터페이스를 추가할 위치를 고려할 때, 현재 계층보다 상위 계층에서 코드를 작성할 수 있는지를 고민해봐야 함.
  1. 같은 계층의 함수는 서로 호출할 수 없다. 그래서 코드가 반복되고 파편화됨. (같은 기능이지만 다르게 작성하는 위험)
  2. 만약 계층이 추상화 벽 형태로 되어 있다면 상위 계층에서는 하위 계층과 의존성이 없게 됨

**편리한 계층(Comfortable layers) 패턴**

- 현실적으로 함수 단위에서 계층을 완벽하게 분리하는 것은 어려움
- 무작정 계층을 나누기보다는, 계층을 추상화함으로써 소프트웨어의 품질과 비즈니스의 문제를 푸는데 도움이 되는지를 먼저 고민해봐야 함.

### 호출 그래프와 비기능적 요구사항

- 기능적인 요구 사항은 소프트웨어가 정확히 해야 하는 일을 말한다.
  - ex) megamart 소프트웨어는 장바구니에 상품을 등록할 수 있다.
- 비기능적 요구 사항은 테스트성, 재사용성, 유지보수성을 말한다.

  1. 유지보수성 : 요구 사항이 변경 시 코드를 쉽게 고칠 수 있는 정도
  2. 테스트성 : 무엇을 테스트하는 게 가장 중요한지?
  3. 재사용성 : 어떤 함수가 재사용하기 좋은지?

- 호출 그래프와 비기능적 요구사항의 관계
  - 유지보수성 : 자주 바뀌는 코드는 가능한 상위 계층에 존재해야 한다.
  - 테스트성 : 하위 계층의 코드를 테스트하자.
    - 하위 계층의 코드일수록 변경 빈도가 작다.
    - 하위 계층의 코드는 상위 계층에 영향을 준다.
  - 재사용성 : 최상위 계층과 최하위 계층의 길이가 적을수록 테스트하기 쉽다.
    - 길이가 작을수록 호출 의존도가 없기 때문에 재사용성이 높아진다.

### 생각 정리

- 테스트 커버리지 `100%`를 목표하는 게 아니라, 먼저 무엇을 테스트할지 결정해야 함.
  - 테스트 대상이 변경 위험이 낮은지?
  - 테스트 대상의 재사용성이 높은지?
- 함수 단위에서 계층을 완벽히 분리하는 것은 어려움.
- 추상화 벽을 잘 세우는 게 중요하다.
  - 추상화 벽을 통해 상위 계층의 코드가 하위 계층의 코드와 의존성이 없도록 해야 함.
